# Stubs for delira.data_loading.dataset (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import abc
import numpy as np
import typing
from torch.utils.data import Dataset as TorchDataset
from typing import Any, Callable, Dict, Iterable, Iterator, List, Tuple, Union

class AbstractDataset(metaclass=abc.ABCMeta):
    data_path: Any = ...
    _load_fn: Any = ...
    data: Any = ...
    def __init__(self, data_path: str, load_fn: typing.Callable) -> Any: ...
    @abc.abstractmethod
    def _make_dataset(self, path: str) -> List[Union[str, Dict[str, np.ndarray]]]: ...
    @abc.abstractmethod
    def __getitem__(self, index: int) -> Dict[str, np.ndarray]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def get_sample_from_index(self, index: Any) -> Dict[str, np.ndarray]: ...
    def get_subset(self, indices: typing.Union[typing.List, typing.Iterable]) -> Any: ...
    def train_test_split(self, *args: Any, **kwargs: Any) -> Tuple[Any, Any]: ...

class _DatasetIter:
    _dset: Any = ...
    _curr_index: int = ...
    def __init__(self, dset: AbstractDataset) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __next__(self) -> Dict[str, np.ndarray]: ...

class BlankDataset(AbstractDataset, metaclass=abc.ABCMeta):
    data: Any = ...
    _old_getitem: Any = ...
    def __init__(self, data: typing.Iterable, old_getitem: Callable, **kwargs: Any) -> Any: ...
    def __getitem__(self, index: int) -> Dict[str, np.ndarray]: ...
    def __len__(self) -> int: ...

class BaseCacheDataset(AbstractDataset):
    _load_kwargs: Any = ...
    data: Any = ...
    def __init__(self, data_path: typing.Union[str, list], load_fn: typing.Callable, **load_kwargs: Any) -> Any: ...
    def _make_dataset(self, path: typing.Union[str, list]) -> List[Dict[str, np.ndarray]]: ...
    def __getitem__(self, index: int) -> Dict[str, np.ndarray]: ...

class BaseLazyDataset(AbstractDataset):
    _load_kwargs: Any = ...
    data: Any = ...
    def __init__(self, data_path: typing.Union[str, List[str]], load_fn: typing.Callable, **load_kwargs: Any) -> Any: ...
    def _make_dataset(self, path: typing.Union[str, List[str]]) -> List[str]: ...
    def __getitem__(self, index: int) -> Dict[str, np.ndarray]: ...

class BaseExtendCacheDataset(BaseCacheDataset):
    def __init__(self, data_path: typing.Union[str, List[str]], load_fn: typing.Callable, **load_kwargs: Any) -> Any: ...
    def _make_dataset(self, path: typing.Union[str, List[str]]) -> List[Dict[str, np.ndarray]]: ...

class ConcatDataset(AbstractDataset, metaclass=abc.ABCMeta):
    data: Any = ...
    def __init__(self, *datasets: AbstractDataset) -> Any: ...
    def get_sample_from_index(self, index: int) -> Dict[str, np.ndarray]: ...
    def __getitem__(self, index: int) -> Dict[str, np.ndarray]: ...
    def __len__(self) -> int: ...

class Nii3DLazyDataset(BaseLazyDataset):
    img_files: Any = ...
    label_file: Any = ...
    def __init__(self, data_path: str, load_fn: Callable, img_files: typing.Union[List[str], Iterable[str]], label_file: str, **load_kwargs: Any) -> Any: ...
    def _make_dataset(self, path: str) -> Any: ...

class Nii3DCacheDatset(BaseCacheDataset):
    img_files: Any = ...
    label_file: Any = ...
    def __init__(self, data_path: str, load_fn: Callable, img_files: Union[List[str], Iterable[str]], label_file: str, **load_kwargs: Any) -> Any: ...
    def _make_dataset(self, path: str) -> List[Union[str, Dict[str, np.ndarray]]]: ...

class TorchvisionClassificationDataset(AbstractDataset):
    download: Any = ...
    train: Any = ...
    root: Any = ...
    img_shape: Any = ...
    num_classes: Any = ...
    one_hot: Any = ...
    data: Any = ...
    def __init__(self, dataset: str, root: str=..., train: bool=..., download: bool=..., img_shape: typing.Union[Tuple[int], List[int], Iterable[int]]=..., one_hot: bool=..., **kwargs: Any) -> Any: ...
    def _make_dataset(self, dataset: str, **kwargs: Any) -> TorchDataset: ...
    def __getitem__(self, index: int) -> Dict[str, np.ndarray]: ...
    def __len__(self) -> int: ...
